import {
  ValidationError,
  NotFoundError,
  ForbiddenError,
} from '../types';
import * as patientRepo from '../repositories/patientRepository';
import logger from '../utils/logger';

/**
 * Patient Service
 * Business logic za patient CRUD operations
 */

export interface CreatePatientDto {
  institution_id: string; // Injected by controller from JWT, not from request body
  first_name: string;
  last_name: string;
  date_of_birth: string;
  address: string;
  unique_code: string; // Auto-generated by controller if not provided
}

export interface UpdatePatientDto {
  first_name?: string;
  last_name?: string;
  date_of_birth?: string;
  address?: string;
}

/**
 * Create new patient
 */
export const createPatient = async (
  data: CreatePatientDto,
  requestingInstitutionId: string
): Promise<patientRepo.PatientDecrypted> => {
  // 1. Verify institution_id matches requesting user's institution
  if (data.institution_id !== requestingInstitutionId) {
    throw new ForbiddenError('Sie können nur Patienten in Ihrer eigenen Institution erstellen');
  }

  // 2. Check if unique_code already exists in this institution
  const existingPatient = await patientRepo.findPatientByCode(
    data.institution_id,
    data.unique_code
  );

  if (existingPatient) {
    throw new ValidationError('Patientennummer existiert bereits in dieser Institution');
  }

  // 3. Validate date format (YYYY-MM-DD)
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(data.date_of_birth)) {
    throw new ValidationError('Geburtsdatum muss im Format YYYY-MM-DD sein');
  }

  // 4. Create patient
  const patientDb = await patientRepo.createPatient(data);

  // 5. Return decrypted patient
  const patient = await patientRepo.findPatientById(patientDb.id);

  if (!patient) {
    throw new Error('Patient wurde erstellt, aber konnte nicht gelesen werden');
  }

  logger.info('Patient created', {
    patientId: patient.id,
    institutionId: data.institution_id,
    uniqueCode: data.unique_code,
  });

  return patient;
};

/**
 * Get patient by ID
 */
export const getPatientById = async (
  patientId: string,
  requestingInstitutionId: string
): Promise<patientRepo.PatientDecrypted> => {
  // 1. Find patient
  const patient = await patientRepo.findPatientById(patientId);

  if (!patient) {
    throw new NotFoundError('Patient nicht gefunden');
  }

  // 2. Verify institution ownership
  if (patient.institution_id !== requestingInstitutionId) {
    throw new ForbiddenError('Sie haben keine Berechtigung für diesen Patienten');
  }

  return patient;
};

/**
 * Get all patients for institution
 */
export const getPatientsByInstitution = async (
  institutionId: string,
  activeOnly: boolean = true
): Promise<patientRepo.PatientDecrypted[]> => {
  const patients = await patientRepo.getPatientsByInstitution(institutionId, activeOnly);

  logger.info('Patients fetched', {
    institutionId,
    count: patients.length,
    activeOnly,
  });

  return patients;
};

/**
 * Update patient
 */
export const updatePatient = async (
  patientId: string,
  data: UpdatePatientDto,
  requestingInstitutionId: string
): Promise<patientRepo.PatientDecrypted> => {
  // 1. Find patient and verify ownership
  const existingPatient = await patientRepo.findPatientById(patientId);

  if (!existingPatient) {
    throw new NotFoundError('Patient nicht gefunden');
  }

  if (existingPatient.institution_id !== requestingInstitutionId) {
    throw new ForbiddenError('Sie haben keine Berechtigung für diesen Patienten');
  }

  // 2. Validate date format if provided
  if (data.date_of_birth) {
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(data.date_of_birth)) {
      throw new ValidationError('Geburtsdatum muss im Format YYYY-MM-DD sein');
    }
  }

  // 3. Update patient
  await patientRepo.updatePatient(patientId, data);

  // 4. Fetch updated patient
  const updatedPatient = await patientRepo.findPatientById(patientId);

  if (!updatedPatient) {
    throw new Error('Patient wurde aktualisiert, aber konnte nicht gelesen werden');
  }

  logger.info('Patient updated', {
    patientId,
    institutionId: requestingInstitutionId,
    updatedFields: Object.keys(data),
  });

  return updatedPatient;
};

/**
 * Deactivate patient (soft delete)
 */
export const deactivatePatient = async (
  patientId: string,
  requestingInstitutionId: string
): Promise<{ message: string }> => {
  // 1. Find patient and verify ownership
  const patient = await patientRepo.findPatientById(patientId);

  if (!patient) {
    throw new NotFoundError('Patient nicht gefunden');
  }

  if (patient.institution_id !== requestingInstitutionId) {
    throw new ForbiddenError('Sie haben keine Berechtigung für diesen Patienten');
  }

  // 2. Check if already deactivated
  if (!patient.is_active) {
    throw new ValidationError('Patient ist bereits deaktiviert');
  }

  // 3. Deactivate
  await patientRepo.deactivatePatient(patientId);

  logger.info('Patient deactivated', {
    patientId,
    institutionId: requestingInstitutionId,
  });

  return {
    message: 'Patient erfolgreich deaktiviert',
  };
};

/**
 * Reactivate patient
 */
export const reactivatePatient = async (
  patientId: string,
  requestingInstitutionId: string
): Promise<{ message: string }> => {
  // 1. Find patient and verify ownership
  const patient = await patientRepo.findPatientById(patientId);

  if (!patient) {
    throw new NotFoundError('Patient nicht gefunden');
  }

  if (patient.institution_id !== requestingInstitutionId) {
    throw new ForbiddenError('Sie haben keine Berechtigung für diesen Patienten');
  }

  // 2. Check if already active
  if (patient.is_active) {
    throw new ValidationError('Patient ist bereits aktiv');
  }

  // 3. Reactivate
  await patientRepo.reactivatePatient(patientId);

  logger.info('Patient reactivated', {
    patientId,
    institutionId: requestingInstitutionId,
  });

  return {
    message: 'Patient erfolgreich reaktiviert',
  };
};

/**
 * Delete patient permanently (GDPR right to erasure)
 */
export const deletePatient = async (
  patientId: string,
  requestingInstitutionId: string
): Promise<{ message: string }> => {
  // 1. Find patient and verify ownership
  const patient = await patientRepo.findPatientById(patientId);

  if (!patient) {
    throw new NotFoundError('Patient nicht gefunden');
  }

  if (patient.institution_id !== requestingInstitutionId) {
    throw new ForbiddenError('Sie haben keine Berechtigung für diesen Patienten');
  }

  // 2. Delete permanently
  await patientRepo.deletePatient(patientId);

  logger.warn('Patient permanently deleted (GDPR)', {
    patientId,
    institutionId: requestingInstitutionId,
  });

  return {
    message: 'Patient wurde dauerhaft gelöscht (GDPR)',
  };
};
